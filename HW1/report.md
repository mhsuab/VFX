# VFX HW1 REPORT
> B05901003 電機三 徐敏倩  
> B06901062 電機三 陳彥霖

## Introduction
This is our report for Homework1, NTUCSIE VFX 2020. In this homework, we recovered HDR image, capturing details in both *light tone* and *dark tone* of high contrast scene. This projec consist of two parts, radiance map construction and tone mapping. For the first part, we chose to implement Debevec's Method for construction; for the second part, we experimented several method and chose the result from Paris' Method of Local Laplacian filters as our final artifact.
![](https://i.imgur.com/u42F7b2.jpg)

**HDR.py** -> construct radiance map and output corresponding `.hdr` file of the input images
**tonemapping.m** -> given a hdr image (`.hdr`) and return its tone-mapped image (`.jpg`)

***Folders***
**original_images** -> save images taken by camera
**result** -> save all images generated by the program

## Requirements
1. Python3
2. Install all python libraries in requirements.txt
3. Matlab

## How to reproduce our result
```shell=
python3 HDR.py
matlab tonemapping.m
```
### Usage: HDR.py
```
usage: HDR.py [-h] [-d DIRECTORY] [-p PREFIX] [-n NUMBER] [-i INDEX]
              [-s SUFFIX] [-f FILENAME] [-a ARRAY]

optional arguments:
  -h, --help    show this help message and exit
  -d DIRECTORY  directory of the input images
  -p PREFIX     prefix of the images
  -n NUMBER     index of first image
  -i INDEX      total number of images
  -s SUFFIX     file type of image
  -f FILENAME   filename of the output numpy array
  -a ARRAY      exist saved np files for images and enter its prefix
```

## Original Images
+ All images are available in folder `original_images`
+ Taken using tripod with aperture *f*/4 and ISO 200
+ Use **Canon EOS 550D**
	+ with **Magic Lantern v2.3**
	+ using *HDR Bracketing* to take 9 images with different exposure time
	+ newer version **Magic Lantern Nightly** have no support on taking HDR images

| Exposure<br/>Time(sec) |**1/4**|**1/2**|**1**|
|:-----------------------:|:--------:|:--------:|:--------:|
|**Images**|![](https://i.imgur.com/DproSXl.jpg)|![](https://i.imgur.com/2hl73YD.jpg)|![](https://i.imgur.com/EX4dhc1.jpg)|
|**Exposure<br/>Time(sec)**|**2**|**4**|**8**|
|**Images**|![](https://i.imgur.com/IFg5A7l.jpg)|![](https://i.imgur.com/I8a06Iz.jpg)|![](https://i.imgur.com/Ej6pUFH.jpg)|
|**Exposure<br/>Time(sec)**|**16**|**32**|**64**|
|**Images**|![](https://i.imgur.com/aTQxlEf.jpg)|![](https://i.imgur.com/cvBjAx1.jpg)|![](https://i.imgur.com/I7BjYFS.jpg)|

## Image Alignment
Align images using opencv class `AlignMTB`.
+ AlignMTB
	+ an implementation of the algorithm, MTB (Median Threshold Bitmap)

## Assemble HDR Image
Assemble HDR Image using [Debevec's Method](https://http://www.pauldebevec.com/Research/HDR/debevec-siggraph97.pdf).

### Sampling Image
+ Select 50 pixels randomly

### Recover Response Curve
Minimizing the following optimization equation to compute response curve.
![](https://i.imgur.com/V7tAlc2.jpg)

For each channel, call function **getCurve()** for it's response curve. 

+ Function **getCurve()**:
    + Construct array **A** and vecor **b**, which transform the former equation to a linear sysyem **Ax = b**.
    + Solve least-square solution for the linear system **Ax=b**
    + Get response curve from the solution
 
#### Response curve result
![](https://i.imgur.com/OasryJ3.png)

### Build Radiance Map
+ Construct weight function
    + weightFunc is shifted to avoid the existence of zero weight
    + ![](https://i.imgur.com/GSXWnV8.png)


Calculate each channel's sensor irradiance by calling function **createHDRImage()**

+ Function **createHDRImage()**
     + Recover the natural log value of irradiance by response curves, weight function, and exposure time with the formula:
         ![](https://i.imgur.com/nxr4ZD3.png)
    and recover irradiance by the exponential value of lnE.
	+ During our implementation, sum of weight may be 0, which causes the equation to crash. Therefore, for these cases, we default the denominator.
    
#### Radiance map result


|  R   |  G   |  B   |
|:----:|:----:|:----:|
|![](https://i.imgur.com/XRyg3vU.png)|![](https://i.imgur.com/Qzw0H5t.png)|![](https://i.imgur.com/lAmgDVk.png)|
|![](https://i.imgur.com/GWPmyCR.png)|![](https://i.imgur.com/uwM4bbR.png)|![](https://i.imgur.com/jqBNTvL.png)|

## Tone Mapping
The final result is at `result/final.jpg`.

Implement 3 different type of tone mapping (in `tonemapping.py`):
+ Gamma Tone Mapping
+ Photographic Tone Reproduction
	+ Global Operator
	+ Local Operator

### Gamma Tone Mapping
We implement the gamma tone mapping, which is relatively easy. For given any image *img* and gamma value *g*,
```python
result = cv2.pow(img/255., 1.0/g)
```
#### result
> *g = 1.3*

![](https://i.imgur.com/4ixGgjA.jpg)
> From the image, we can find that even with *light tone* being overexposed the *dark tone* is still not bright enough to show all its details.

### Photographic Tone Reproduction (Global Operator)
Implement code to achieve the follow equations, where every pixel in the image follow the same modified function:

![](https://i.imgur.com/Rnifqqp.png)
![](https://i.imgur.com/aDkSg9d.png)
![](https://i.imgur.com/IqPDEf0.png)

#### result
|*a=0.1, d=1e-1*|*a=0.1,d=1e-12*|*a=0.05,d=1e-12*|
|:-:|:-:|:-:|
|![](https://i.imgur.com/u6f2mr5.jpg)|![](https://i.imgur.com/1sK1I27.jpg)|![](https://i.imgur.com/RKj9zHk.jpg)|

### Photographic Tone Reproduction (Local Operator)
Similar to *Global Operator*, only that it also local characteristic into consideration. Therefore, the equations will be modified and result in brighten or darken certain area in the image.
![](https://i.imgur.com/tA9WFsz.png)


#### result
|*a=0.1, d=1e-1*|*a=0.1,d=1e-12*|*a=0.05,d=1e-12*|
|:-:|:-:|:-:|
|![](https://i.imgur.com/5U4lLTp.jpg)|![](https://i.imgur.com/jG0vKVF.jpg)|![](https://i.imgur.com/n3kCaHO.jpg)|

### Tone Mapping with build-in function in Matlab
However, being unable to implement a satisfying result by ourselves, showing details for both *light tone* and *dark tone*. We turned into using build-in functions in Matlab, *[tonemap()](https://www.mathworks.com/help/images/ref/tonemap.html)* and *[localtonemap()](https://www.mathworks.com/help/images/ref/localtonemap.html)*.
`localtonemap(), implementation of Local Laplacian filters`

> both result in function's default settings

|*tonemap()*|*localtonemap()*|
|:-:|:-:|
|![](https://i.imgur.com/KPLZdrQ.jpg)|![](https://i.imgur.com/NsRgkVR.jpg)|
Choose *localtonemape()* other than *tonemap()* due to our personal preference.

#### adjust value of RangeCompression
|0.3|0.5|
|:-:|:-:|
|![](https://i.imgur.com/41axX6z.jpg)|![](https://i.imgur.com/0VBp6PB.jpg)|
#### adjust value of EnhanceContrast
|0.3|0.5|0.7|
|:-:|:-:|:-:|
|![](https://i.imgur.com/4YOGw4E.jpg)|![](https://i.imgur.com/yZSFwsU.jpg)|![](https://i.imgur.com/42EZsEu.jpg)|
### Final Result
> Choose tone-mapped image generated from *localtonemap()* with RangeCompression = 0.3 and EnhanceContrast = 0.7

![](https://i.imgur.com/u42F7b2.jpg)

## Problem
|![](https://i.imgur.com/2gktLIx.jpg)|![](https://i.imgur.com/u42F7b2.jpg)|
|:-:|:-:|
|weighting function: `w(z)`|weighting function: `w'(z)`|  

Since certain part of the intensity has almost same intensity in all 9 images, due to our weighting function `w(z)`, they may result in extremely small value. Therefore, to avoid the problem, we adjust our weighting function by shifting 10 unit higher, `w'(z) = w(z) + 10`.
![](https://i.imgur.com/GSXWnV8.png)


## Extensions
+ Implement 3 tone mapping functions


## What we have learned in this project
+ Knowledge about how cameras change light signal into images
+ Knowledge of using Canon's Magic Lantern for taking HDR images
+ Algorithm to recover HDR image
+ The use of OpenCV
+ Algorithm for tone mapping
+ Searching for corresponding functions in Matlab

## Reference
+ Paul E. Debevec, Jitendra Malik, Recovering High Dynamic Range Radiance Maps from Photographs, SIGGRAPH 1997.
+ Erik Reinhard, Michael Stark, Peter Shirley, Jim Ferwerda, Photographics Tone Reproduction for Digital Images, SIGGRAPH 2002.
+ Paris, Sylvain, Samuel W. Hasinoff, and Jan Kautz. "c: edge-aware image processing with a Laplacian pyramid." ACM Trans. Graph. 30.4 (2011): 68.